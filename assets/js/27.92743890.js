(window.webpackJsonp=window.webpackJsonp||[]).push([[27],{192:function(s,n,a){"use strict";a.r(n);var e=a(0),t=Object(e.a)({},(function(){var s=this.$createElement;this._self._c;return this._m(0)}),[function(){var s=this,n=s.$createElement,a=s._self._c||n;return a("div",{staticClass:"content"},[a("h1",{attrs:{id:"_3个使用场景助你用好-dom-事件"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3个使用场景助你用好-dom-事件"}},[s._v("#")]),s._v(" 3个使用场景助你用好 DOM 事件")]),s._v(" "),a("p",[s._v("DOM 事件数量非常多，即使分类也有十多种，比如键盘事件、鼠标事件、表单事件等，而且不同事件对象属性也有差异，这带来了一定的学习难度。")]),s._v(" "),a("p",[s._v("但页面要与用户交互，接收用户输入，就离不开监听元素事件，所以，DOM 事件是前端工程师必须掌握的重要内容，同时也是 DOM 的重要组成部分。")]),s._v(" "),a("p",[s._v("下面我们就从防抖、节流、代理 3 个场景出发，详细了解 DOM 事件。")]),s._v(" "),a("h2",{attrs:{id:"_1-防抖"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-防抖"}},[s._v("#")]),s._v(" 1. 防抖")]),s._v(" "),a("p",[s._v("试想这样的一个场景，有一个搜索输入框，为了提升用户体验，希望在用户输入后可以立即展现搜索结果，而不是每次输入完后还要点击搜索按钮。最基本的实现方式应该很容易想到，那就是绑定 input 元素的键盘事件，然后在监听函数中发送 AJAX 请求。伪代码如下：")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("const ipt = document.querySelector('input')\nipt.addEventListener('input', e => {\n  search(e.target.value).then(resp => {\n    // ...\n  }, e => {\n    // ...\n  })\n})\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br")])]),a("p",[s._v("但其实这样的写法很容易造成性能问题。比如当用户在搜索“lagou”这个词的时候，每一次输入都会触发搜索：")]),s._v(" "),a("p",[s._v("搜索“l”")]),s._v(" "),a("p",[s._v("搜索“la”")]),s._v(" "),a("p",[s._v("搜索“lag”")]),s._v(" "),a("p",[s._v("搜索“lago”")]),s._v(" "),a("p",[s._v("搜索“lagou”")]),s._v(" "),a("p",[s._v("而实际上，只有最后一次搜索结果是用户想要的，前面进行了 4 次无效查询，浪费了网络带宽和服务器资源。")]),s._v(" "),a("p",[s._v("所以对于这类连续触发的事件，需要添加一个 "),a("strong",[s._v("“防抖”功能")]),s._v("，为函数的执行设置一个合理的时间间隔，避免事件在时间间隔内频繁触发，同时又保证用户输入后能即时看到搜索结果。")]),s._v(" "),a("p",[s._v("要实现这样一个功能我们很容易想到使用 setTimeout() 函数来让函数延迟执行。就像下面的伪代码，当每次调用函数时，先判断 timeout 实例是否存在，如果存在则销毁，然后创建一个新的定时器。")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("// 代码1\nconst ipt = document.querySelector('input')\nlet timeout = null\nipt.addEventListener('input', e => {\n  if(timeout) {\n    clearTimeout(timeout)\n    timeout = null\n  }\n  timeout = setTimeout(() => {\n    search(e.target.value).then(resp => {\n      // ...\n    }, e => {\n      // ...\n    })\n  }, 500)\n})\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br"),a("span",{staticClass:"line-number"},[s._v("9")]),a("br"),a("span",{staticClass:"line-number"},[s._v("10")]),a("br"),a("span",{staticClass:"line-number"},[s._v("11")]),a("br"),a("span",{staticClass:"line-number"},[s._v("12")]),a("br"),a("span",{staticClass:"line-number"},[s._v("13")]),a("br"),a("span",{staticClass:"line-number"},[s._v("14")]),a("br"),a("span",{staticClass:"line-number"},[s._v("15")]),a("br"),a("span",{staticClass:"line-number"},[s._v("16")]),a("br")])]),a("p",[s._v("问题确实是解决了，但这并不是最优答案，或者说我们需对这个防抖操作进行一些“优化”。")]),s._v(" "),a("p",[s._v("试想一下，如果另一个搜索框也需要添加防抖，是不是也要把 timeout 相关的代码再编写一次？而其实这个操作是完全可以抽取成"),a("strong",[s._v("公共函数")]),s._v("的。")]),s._v(" "),a("p",[s._v("在抽取成公共函数的同时，还需要考虑更复杂的情况：")]),s._v(" "),a("ul",[a("li",[a("p",[s._v("参数和返回值如何传递？")])]),s._v(" "),a("li",[a("p",[s._v("防抖化之后的函数是否可以立即执行？")])]),s._v(" "),a("li",[a("p",[s._v("防抖化的函数是否可以手动取消？")])])]),s._v(" "),a("p",[s._v("具体代码如下所示，首先将原函数作为参数传入 debounce() 函数中，同时指定延迟等待时间，返回一个新的函数，这个函数包含 cancel 属性，用来取消原函数执行。flush 属性用来立即调用原函数，同时将原函数的执行结果以 Promise 的形式返回。")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("// 代码2\nconst debounce = (func, wait = 0) => {\n  let timeout = null\n  let args\n  function debounced(...arg) {\n    args = arg\n    if(timeout) {\n      clearTimeout(timeout)\n      timeout = null\n    }\n    // 以Promise的形式返回函数执行结果\n    return new Promise((res, rej) => {\n      timeout = setTimeout(async () => {\n        try {\n          const result = await func.apply(this, args)\n          res(result)\n        } catch(e) {\n          rej(e)\n        }\n      }, wait)\n    })\n  }\n  // 允许取消\n  function cancel() {\n    clearTimeout(timeout)\n    timeout = null\n  }\n  // 允许立即执行\n  function flush() {\n    cancel()\n    return func.apply(this, args)\n  }\n  debounced.cancel = cancel\n  debounced.flush = flush\n  return debounced\n}\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br"),a("span",{staticClass:"line-number"},[s._v("9")]),a("br"),a("span",{staticClass:"line-number"},[s._v("10")]),a("br"),a("span",{staticClass:"line-number"},[s._v("11")]),a("br"),a("span",{staticClass:"line-number"},[s._v("12")]),a("br"),a("span",{staticClass:"line-number"},[s._v("13")]),a("br"),a("span",{staticClass:"line-number"},[s._v("14")]),a("br"),a("span",{staticClass:"line-number"},[s._v("15")]),a("br"),a("span",{staticClass:"line-number"},[s._v("16")]),a("br"),a("span",{staticClass:"line-number"},[s._v("17")]),a("br"),a("span",{staticClass:"line-number"},[s._v("18")]),a("br"),a("span",{staticClass:"line-number"},[s._v("19")]),a("br"),a("span",{staticClass:"line-number"},[s._v("20")]),a("br"),a("span",{staticClass:"line-number"},[s._v("21")]),a("br"),a("span",{staticClass:"line-number"},[s._v("22")]),a("br"),a("span",{staticClass:"line-number"},[s._v("23")]),a("br"),a("span",{staticClass:"line-number"},[s._v("24")]),a("br"),a("span",{staticClass:"line-number"},[s._v("25")]),a("br"),a("span",{staticClass:"line-number"},[s._v("26")]),a("br"),a("span",{staticClass:"line-number"},[s._v("27")]),a("br"),a("span",{staticClass:"line-number"},[s._v("28")]),a("br"),a("span",{staticClass:"line-number"},[s._v("29")]),a("br"),a("span",{staticClass:"line-number"},[s._v("30")]),a("br"),a("span",{staticClass:"line-number"},[s._v("31")]),a("br"),a("span",{staticClass:"line-number"},[s._v("32")]),a("br"),a("span",{staticClass:"line-number"},[s._v("33")]),a("br"),a("span",{staticClass:"line-number"},[s._v("34")]),a("br"),a("span",{staticClass:"line-number"},[s._v("35")]),a("br"),a("span",{staticClass:"line-number"},[s._v("36")]),a("br")])]),a("p",[s._v("我们在写代码解决当前问题的时候，最初只能写出像代码 1 那样满足需求的代码。但要成为高级工程师，就一定要将问题再深想一层，比如代码如何抽象成公共函数，才能得到较为完善的代码 2，从而自身得到成长。")]),s._v(" "),a("p",[s._v("关于防抖函数还有功能更丰富的版本，比如 lodash 的 debounce() 函数，有兴趣的话可以到 GitHub 上查阅资料。")]),s._v(" "),a("h2",{attrs:{id:"_2-节流"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-节流"}},[s._v("#")]),s._v(" 2. 节流")]),s._v(" "),a("p",[s._v("现在来考虑另外一个场景，一个左右两列布局的查看文章页面，左侧为文章大纲结构，右侧为文章内容。现在需要添加一个功能，就是当用户滚动阅读右侧文章内容时，左侧大纲相对应部分高亮显示，提示用户当前阅读位置。")]),s._v(" "),a("p",[s._v("这个功能的实现思路比较简单，滚动前先记录大纲中各个章节的垂直距离，然后监听 scroll 事件的滚动距离，根据距离的比较来判断需要高亮的章节。伪代码如下：")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("// 监听scroll事件\nwrap.addEventListener('scroll', e => {\n  let highlightId = ''\n  // 遍历大纲章节位置，与滚动距离比较，得到当前高亮章节id\n  for (let id in offsetMap) {\n    if (e.target.scrollTop <= offsetMap[id].offsetTop) {\n      highlightId = id\n      break\n    }\n  }\n  const lastDom = document.querySelector('.highlight')\n  const currentElem = document.querySelector(`a[href=\"#${highlightId}\"]`)\n  // 修改高亮样式\n  if (lastDom && lastDom.id !== highlightId) {\n    lastDom.classList.remove('highlight')\n    currentElem.classList.add('highlight')\n  } else {\n    currentElem.classList.add('highlight')\n  }\n})\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br"),a("span",{staticClass:"line-number"},[s._v("9")]),a("br"),a("span",{staticClass:"line-number"},[s._v("10")]),a("br"),a("span",{staticClass:"line-number"},[s._v("11")]),a("br"),a("span",{staticClass:"line-number"},[s._v("12")]),a("br"),a("span",{staticClass:"line-number"},[s._v("13")]),a("br"),a("span",{staticClass:"line-number"},[s._v("14")]),a("br"),a("span",{staticClass:"line-number"},[s._v("15")]),a("br"),a("span",{staticClass:"line-number"},[s._v("16")]),a("br"),a("span",{staticClass:"line-number"},[s._v("17")]),a("br"),a("span",{staticClass:"line-number"},[s._v("18")]),a("br"),a("span",{staticClass:"line-number"},[s._v("19")]),a("br"),a("span",{staticClass:"line-number"},[s._v("20")]),a("br")])]),a("p",[s._v("功能是实现了，但这并不是最优方法，因为滚动事件的触发频率是很高的，持续调用判断函数很可能会影响渲染性能。实际上也不需要过于频繁地调用，因为当鼠标滚动 1 像素的时候，很有可能当前章节的阅读并没有发生变化。所以我们可以设置在指定一段时间内只调用一次函数，从而降低函数调用频率，这种方式我们称之为 "),a("strong",[s._v("“节流”")]),s._v(" 。")]),s._v(" "),a("p",[s._v("实现节流函数的过程和防抖函数有些类似，只是对于节流函数而言，有两种执行方式，在调用函数时执行最先一次调用还是最近一次调用，所以需要设置时间戳加以判断。我们可以基于 debounce() 函数加以修改，代码如下所示：")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("const throttle = (func, wait = 0, execFirstCall) => {\n  let timeout = null\n  let args\n  let firstCallTimestamp\n\n\n  function throttled(...arg) {\n    if (!firstCallTimestamp) firstCallTimestamp = new Date().getTime()\n    if (!execFirstCall || !args) {\n      console.log('set args:', arg)\n      args = arg\n    }\n    if (timeout) {\n      clearTimeout(timeout)\n      timeout = null\n    }\n    // 以Promise的形式返回函数执行结果\n    return new Promise(async(res, rej) => {\n      if (new Date().getTime() - firstCallTimestamp >= wait) {\n        try {\n          const result = await func.apply(this, args)\n          res(result)\n        } catch (e) {\n          rej(e)\n        } finally {\n          cancel()\n        }\n      } else {\n        timeout = setTimeout(async () => {\n          try {\n            const result = await func.apply(this, args)\n            res(result)\n          } catch (e) {\n            rej(e)\n          } finally {\n            cancel()\n          }\n        }, firstCallTimestamp + wait - new Date().getTime())\n      }\n    })\n  }\n  // 允许取消\n  function cancel() {\n    clearTimeout(timeout)\n    args = null\n    timeout = null\n    firstCallTimestamp = null\n  }\n  // 允许立即执行\n  function flush() {\n    cancel()\n    return func.apply(this, args)\n  }\n  throttled.cancel = cancel\n  throttled.flush = flush\n  return throttled\n}\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br"),a("span",{staticClass:"line-number"},[s._v("9")]),a("br"),a("span",{staticClass:"line-number"},[s._v("10")]),a("br"),a("span",{staticClass:"line-number"},[s._v("11")]),a("br"),a("span",{staticClass:"line-number"},[s._v("12")]),a("br"),a("span",{staticClass:"line-number"},[s._v("13")]),a("br"),a("span",{staticClass:"line-number"},[s._v("14")]),a("br"),a("span",{staticClass:"line-number"},[s._v("15")]),a("br"),a("span",{staticClass:"line-number"},[s._v("16")]),a("br"),a("span",{staticClass:"line-number"},[s._v("17")]),a("br"),a("span",{staticClass:"line-number"},[s._v("18")]),a("br"),a("span",{staticClass:"line-number"},[s._v("19")]),a("br"),a("span",{staticClass:"line-number"},[s._v("20")]),a("br"),a("span",{staticClass:"line-number"},[s._v("21")]),a("br"),a("span",{staticClass:"line-number"},[s._v("22")]),a("br"),a("span",{staticClass:"line-number"},[s._v("23")]),a("br"),a("span",{staticClass:"line-number"},[s._v("24")]),a("br"),a("span",{staticClass:"line-number"},[s._v("25")]),a("br"),a("span",{staticClass:"line-number"},[s._v("26")]),a("br"),a("span",{staticClass:"line-number"},[s._v("27")]),a("br"),a("span",{staticClass:"line-number"},[s._v("28")]),a("br"),a("span",{staticClass:"line-number"},[s._v("29")]),a("br"),a("span",{staticClass:"line-number"},[s._v("30")]),a("br"),a("span",{staticClass:"line-number"},[s._v("31")]),a("br"),a("span",{staticClass:"line-number"},[s._v("32")]),a("br"),a("span",{staticClass:"line-number"},[s._v("33")]),a("br"),a("span",{staticClass:"line-number"},[s._v("34")]),a("br"),a("span",{staticClass:"line-number"},[s._v("35")]),a("br"),a("span",{staticClass:"line-number"},[s._v("36")]),a("br"),a("span",{staticClass:"line-number"},[s._v("37")]),a("br"),a("span",{staticClass:"line-number"},[s._v("38")]),a("br"),a("span",{staticClass:"line-number"},[s._v("39")]),a("br"),a("span",{staticClass:"line-number"},[s._v("40")]),a("br"),a("span",{staticClass:"line-number"},[s._v("41")]),a("br"),a("span",{staticClass:"line-number"},[s._v("42")]),a("br"),a("span",{staticClass:"line-number"},[s._v("43")]),a("br"),a("span",{staticClass:"line-number"},[s._v("44")]),a("br"),a("span",{staticClass:"line-number"},[s._v("45")]),a("br"),a("span",{staticClass:"line-number"},[s._v("46")]),a("br"),a("span",{staticClass:"line-number"},[s._v("47")]),a("br"),a("span",{staticClass:"line-number"},[s._v("48")]),a("br"),a("span",{staticClass:"line-number"},[s._v("49")]),a("br"),a("span",{staticClass:"line-number"},[s._v("50")]),a("br"),a("span",{staticClass:"line-number"},[s._v("51")]),a("br"),a("span",{staticClass:"line-number"},[s._v("52")]),a("br"),a("span",{staticClass:"line-number"},[s._v("53")]),a("br"),a("span",{staticClass:"line-number"},[s._v("54")]),a("br"),a("span",{staticClass:"line-number"},[s._v("55")]),a("br"),a("span",{staticClass:"line-number"},[s._v("56")]),a("br"),a("span",{staticClass:"line-number"},[s._v("57")]),a("br")])]),a("p",[s._v("节流与防抖都是通过延迟执行，减少调用次数，来优化频繁调用函数时的性能。不同的是，对于一段时间内的频繁调用，防抖是延迟执行后一次调用，节流是延迟定时多次调用。")]),s._v(" "),a("h2",{attrs:{id:"_3-代理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-代理"}},[s._v("#")]),s._v(" 3. 代理")]),s._v(" "),a("p",[s._v("下面的 HTML 代码是一个简单的无序列表，现在希望点击每个项目的时候调用 getInfo() 函数，当点击“编辑”时，调用一个 edit() 函数，当点击“删除”时，调用一个 del() 函数。")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v('<ul class="list">\n  <li class="item" id="item1">项目1<span class="edit">编辑</span><span class="delete">删除</span></li>\n  <li class="item" id="item2">项目2<span class="edit">编辑</span><span class="delete" >删除</span></li>\n  <li class="item" id="item3">项目3<span class="edit">编辑</span><span class="delete">删除</span></li>\n  ...\n</ul>\n')])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br")])]),a("p",[s._v("要实现这个功能并不难，只需要对列表中每一项，分别监听 3 个元素的 click 事件即可。")]),s._v(" "),a("p",[s._v("但如果数据量一旦增大，事件绑定占用的内存以及执行时间将会成线性增加，而其实这些事件监听函数逻辑一致，只是参数不同而已。此时我们可以以"),a("strong",[s._v("事件代理")]),s._v("或"),a("strong",[s._v("事件委托")]),s._v("来进行优化。不过在此之前，我们必须先复习一下 DOM 事件的触发流程。")]),s._v(" "),a("p",[s._v("事件触发流程如图 1 所示，主要分为 3 个阶段：")]),s._v(" "),a("ul",[a("li",[a("p",[a("strong",[s._v("捕获")]),s._v("，事件对象 Window 传播到目标的父对象，图 1 的红色过程；")])]),s._v(" "),a("li",[a("p",[a("strong",[s._v("目标")]),s._v("，事件对象到达事件对象的事件目标，图 1 的蓝色过程；")])]),s._v(" "),a("li",[a("p",[a("strong",[s._v("冒泡")]),s._v("，事件对象从目标的父节点开始传播到 Window，图 1 的绿色过程。")])])]),s._v(" "),a("p",[a("img",{attrs:{src:"https://s0.lgstatic.com/i/image/M00/0C/D6/Ciqc1F7DSJ6AEL__AAFZ8Y41LLM325.png",alt:"Image text"}})]),s._v(" "),a("p",[s._v("例如，在下面的代码中，虽然我们第二次进行事件监听时设置为捕获阶段，但点击事件时仍会按照监听顺序进行执行。")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("<body>\n  <button>click</button>\n</body>\n<script>\ndocument.querySelector('button').addEventListener('click', function () {\n  console.log('bubble')\n})\ndocument.querySelector('button').addEventListener('click', function () {\n  console.log('capture')\n}, true)\n// 执行结果\n// buble\n// capture\n<\/script>\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br"),a("span",{staticClass:"line-number"},[s._v("9")]),a("br"),a("span",{staticClass:"line-number"},[s._v("10")]),a("br"),a("span",{staticClass:"line-number"},[s._v("11")]),a("br"),a("span",{staticClass:"line-number"},[s._v("12")]),a("br"),a("span",{staticClass:"line-number"},[s._v("13")]),a("br"),a("span",{staticClass:"line-number"},[s._v("14")]),a("br")])]),a("p",[s._v("我们再回到事件代理，事件代理的实现原理就是利用上述 DOM 事件的触发流程来对一类事件进行统一处理。比如对于上面的列表，我们在 ul 元素上绑定事件统一处理，通过得到的事件对象来获取参数，调用对应的函数。")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("const ul = document.querySelector('.list')\nul.addEventListener('click', e => {\n  const t = e.target || e.srcElement\n  if (t.classList.contains('item')) {\n    getInfo(t.id)\n  } else {\n    id = t.parentElement.id\n    if (t.classList.contains('edit')) {\n      edit(id)\n    } else if (t.classList.contains('delete')) {\n      del(id)\n    }\n  }\n})\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br"),a("span",{staticClass:"line-number"},[s._v("9")]),a("br"),a("span",{staticClass:"line-number"},[s._v("10")]),a("br"),a("span",{staticClass:"line-number"},[s._v("11")]),a("br"),a("span",{staticClass:"line-number"},[s._v("12")]),a("br"),a("span",{staticClass:"line-number"},[s._v("13")]),a("br"),a("span",{staticClass:"line-number"},[s._v("14")]),a("br")])]),a("p",[s._v("虽然这里我们选择了默认在冒泡阶段监听事件，但和捕获阶段监听并没有区别。对于其他情况还需要具体情况具体细分析，比如有些列表项目需要在目标阶段进行一些预处理操作，那么可以选择冒泡阶段进行事件代理。")]),s._v(" "),a("h2",{attrs:{id:"_4-关于-dom-事件标准"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4-关于-dom-事件标准"}},[s._v("#")]),s._v(" 4. 关于 DOM 事件标准")]),s._v(" "),a("p",[s._v("你知道下面 3 种事件监听方式的区别吗？")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("// 方式1\n<input type=\"text\" onclick=\"click()\"/>\n// 方式2\ndocument.querySelector('input').onClick = function(e) {\n  // ...\n}\n// 方式3\ndocument.querySelector('input').addEventListener('click', function(e) {\n  //...\n})\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br"),a("span",{staticClass:"line-number"},[s._v("9")]),a("br"),a("span",{staticClass:"line-number"},[s._v("10")]),a("br")])]),a("p",[s._v("方式 1 和方式 2 同属于 DOM0 标准，通过这种方式进行事件监会覆盖之前的事件监听函数。")]),s._v(" "),a("p",[s._v("方式 3 属于 DOM2 标准，推荐使用这种方式。同一元素上的事件监听函数互不影响，而且可以独立取消，调用顺序和监听顺序一致。")])])}],!1,null,null,null);n.default=t.exports}}]);